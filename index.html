<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gratitude</title>
    <style type="text/css">
        html, body {
            margin: 0;
        }
    </style>
    <script src="js/pixi.min.js"></script>
    <script src="js/viewport.js"></script>
    <!-- PIXI.js -->
    <script>
        var app;
        var vp;
        var buttonTexture, downTexture;
        
        window.onload = function () {
            app = new PIXI.Application({ width: window.innerWidth, height: window.innerHeight, backgroundColor: 0x1099bb });
            document.body.appendChild(app.view);

            //create the main viewport
            vp = new Viewport.Viewport({
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight,
                worldWidth: 1000,
                worldHeight: 1000,

                interaction: app.renderer.plugins.interaction // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
            })

            // add the viewport to the stage
            app.stage.addChild(vp)
            // activate plugins
            vp
                .drag()
                .pinch()
                .wheel()
                .decelerate()

            // add a red box
            const sprite = vp.addChild(new PIXI.Sprite(PIXI.Texture.WHITE))
            sprite.tint = 0xff0000
            sprite.width = sprite.height = 100
            sprite.position.set(100, 100)

            //preload assets
            app.loader.baseUrl = "images";
            app.loader.add("sprite01", "mj1.png");
            app.loader.add("sprite02", "mj2.png");
            app.loader.add("sprite03", "mj3.png");
            app.loader.add("sprite04", "mj4.png");
            app.loader.add("sprite05", "mj5.png");
            app.loader.add("sprite06", "mj6.png");
            app.loader.add("sprite07", "mj7.png");
            app.loader.add("sprite08", "mj8.png");
            app.loader.add("sprite09", "mj9.png");
            app.loader.add("sprite10", "mj10.png");

            app.loader.onProgress.add(showProgress);
            app.loader.onComplete.add(doneLoading);
            app.loader.onError.add(showError);

            app.loader.load();
        }

        function showProgress(e) {
            console.log(e.progress);
        }

        function showError(e) {
            console.error("ERROR: " + e.message);
        }

        function doneLoading(e) {
            console.log("Done loading!");
            plaza();
        }

        function plaza() {
            buttonTexture = app.loader.resources.sprite01.texture;
            downTexture = app.loader.resources.sprite02.texture;

            const buttons = [];
            const x_dif = app.view.width/4;
            const y_dif = app.view.height/4;
            const buttonPositions = [
                200, 400,
                200, 900,
                700, 350,
                400, 600,
                500, 500,
            ];

            for (let i = 0; i < buttonPositions.length; i++) {
                const button = new PIXI.Sprite(buttonTexture);

                button.anchor.set(0.5);
                button.x = buttonPositions[i * 2];
                button.y = buttonPositions[i * 2 + 1];

                // make the button interactive...
                button.interactive = true;
                button.buttonMode = true;

                button
                // Mouse & touch events are normalized into
                // the pointer* events for handling different
                // button events.
                    .on('pointerdown', onButtonDown)
                    .on('pointerup', onButtonUp)
                    .on('pointerupoutside', onButtonUp)
                    .on('pointerover', onButtonOver)
                    .on('pointerout', onButtonOut);


                button.scale.set(0.4); //SCALE down michael jackson

                // add it to the stage
                vp.addChild(button);
                // add button to array
                buttons.push(button);
            }
        }


        function onButtonDown() {
            this.isdown = true;
            this.texture = downTexture;
            this.alpha = 1;
        }

        function onButtonUp() {
            this.isdown = false;
            // if (this.isOver) {
            //     this.texture = textureButtonOver;
            // } else {
            //     this.texture = buttonTexture;
            // }
            this.texture = buttonTexture;
        }

        function onButtonOver() { //hover
            // this.isOver = true;
            // if (this.isdown) {
            //     return;
            // }
            // this.texture = textureButtonOver;
        }

        function onButtonOut() {
            // this.isOver = false;
            // if (this.isdown) {
            //     return;
            // }
            // this.texture = textureButton;
        }

        // hit area where alpha = 1 (no transparent boxes)
        PIXI.Sprite.prototype.containsPoint = function (point) {
            const tempPoint = {x: 0, y: 0 }
            this.worldTransform.applyInverse(point, tempPoint);
            console.log(tempPoint);

            const width = this._texture.orig.width;
            const height = this._texture.orig.height;
            const x1 = -width * this.anchor.x;
            let y1 = 0;

            let flag = false;

            if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
                y1 = -height * this.anchor.y;

                if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
                    flag = true;
                }
            }

            if (!flag) {
                return false
            }
            // bitmap check
            const tex = this.texture;
            const baseTex = this.texture.baseTexture;
            const res = baseTex.resolution;
            if (!baseTex.hitmap) {

                if (!genHitmap(baseTex, 127)) {
                    return true;
                }
                
            }

            const hitmap = baseTex.hitmap;
            // this does not account for rotation yet!!!
            let dx = Math.round((tempPoint.x - x1 + tex.frame.x) * res);
            let dy = Math.round((tempPoint.y - y1 + tex.frame.y) * res);
            let ind = (dx + dy * baseTex.realWidth);
            let ind1 = ind % 32;
            let ind2 = ind / 32 | 0;
            return (hitmap[ind2] & (1 << ind1)) !== 0;
        }

        function genHitmap(baseTex, threshold) {
            if (!baseTex.resource) {
                //renderTexture
                return false;
            }
            const imgSource = baseTex.resource.source;
            let canvas = null;
            if (!imgSource) {
                return false;
            }
            let context = null;
            if (imgSource.getContext) {
                canvas = imgSource;
                context = canvas.getContext('2d');
            } else if (imgSource instanceof Image) {
                canvas = document.createElement('canvas');
                canvas.width = imgSource.width;
                canvas.height = imgSource.height;
                context = canvas.getContext('2d');
                context.drawImage(imgSource, 0, 0);
            } else {
                //unknown source;
                return false;
            }

            const w = canvas.width, h = canvas.height;
            let imageData = context.getImageData(0, 0, w, h);
            let hitmap = baseTex.hitmap = new Uint32Array(Math.ceil(w * h / 32));
            for (let i = 0; i < w * h; i++) {
                let ind1 = i % 32;
                let ind2 = i / 32 | 0;
                if (imageData.data[i * 4 + 3] >= threshold) {
                    hitmap[ind2] = hitmap[ind2] | (1 << ind1);
                }
            }
            return true;
        }
    </script>
</head>
<body>
    
</body>
</html>